import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import type { Task } from "@/lib/types";

function getSupabase() {
  const url = process.env.SUPABASE_URL;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_ANON_KEY;
  if (!url || !key) return null;
  return createClient(url, key, { auth: { persistSession: false } });
}

const TABLE = "qaqc_tasks";

export async function GET(req: Request) {
  const sb = getSupabase();
  if (!sb) {
    return NextResponse.json(
      { error: "Supabase env missing. Set SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY (recommended) or SUPABASE_ANON_KEY." },
      { status: 400 }
    );
  }

  const { searchParams } = new URL(req.url);
  const workspaceId = searchParams.get("workspaceId") ?? "";
  const since = searchParams.get("since") ?? "1970-01-01T00:00:00.000Z";
  if (!workspaceId) {
    return NextResponse.json({ error: "workspaceId is required" }, { status: 400 });
  }

  const { data, error } = await sb
    .from(TABLE)
    .select("id,workspace_id,payload,updated_at")
    .eq("workspace_id", workspaceId)
    .gt("updated_at", since)
    .order("updated_at", { ascending: true });

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  const tasks: Task[] = (data ?? []).map((row: unknown) => row.payload as Task);
  const serverTime = new Date().toISOString();
  return NextResponse.json({ tasks, serverTime });
}

export async function POST(req: Request) {
  const sb = getSupabase();
  if (!sb) {
    return NextResponse.json(
      { error: "Supabase env missing. Set SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY (recommended) or SUPABASE_ANON_KEY." },
      { status: 400 }
    );
  }

  const { searchParams } = new URL(req.url);
  const workspaceId = searchParams.get("workspaceId") ?? "";
  if (!workspaceId) {
    return NextResponse.json({ error: "workspaceId is required" }, { status: 400 });
  }

  const body = (await req.json().catch(() => ({}))) as { tasks?: Task[] };
  const tasks = Array.isArray(body?.tasks) ? body.tasks : [];
  const now = new Date().toISOString();

  const rows = tasks.map((t) => {
    const updatedAt = t.updatedAt || now;
    return {
      id: t.id,
      workspace_id: workspaceId,
      updated_at: updatedAt,
      payload: { ...t, workspaceId },
    };
  });

  if (rows.length) {
    const { error } = await sb.from(TABLE).upsert(rows, {
      onConflict: "workspace_id,id",
    });
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
  }

  return NextResponse.json({ pushed: rows.length, pulled: 0, serverTime: now });
}
